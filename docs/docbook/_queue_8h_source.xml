<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="__queue_8h_source" xml:lang="en-US">
<title>Queue.h</title>
<indexterm><primary>D:/Coding/S3GF/src/MultiThread/Queue.h</primary></indexterm>
<programlisting linenumbering="unnumbered">1 <emphasis role="preprocessor">#pragma&#32;once</emphasis>
2 <emphasis role="preprocessor">#ifndef&#32;QUEUE_H</emphasis>
3 <emphasis role="preprocessor">#define&#32;QUEUE_H</emphasis>
4 <emphasis role="preprocessor">#include&#32;&quot;Libs.h&quot;</emphasis>
5 
6 <emphasis role="keyword">namespace&#32;</emphasis><link linkend="_namespace_s3_g_f">S3GF</link>&#32;{
7 &#32;&#32;&#32;&#32;<emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">typename</emphasis>&#32;T&gt;
8 &#32;&#32;&#32;&#32;<emphasis role="keyword">class&#32;</emphasis>TaskQueue&#32;{
9 &#32;&#32;&#32;&#32;<emphasis role="keyword">public</emphasis>:
10 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;TaskQueue(TaskQueue&#32;&amp;&amp;)&#32;=&#32;<emphasis role="keyword">delete</emphasis>;
11 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;TaskQueue(<emphasis role="keyword">const</emphasis>&#32;TaskQueue&#32;&amp;)&#32;=&#32;<emphasis role="keyword">delete</emphasis>;
12 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;TaskQueue&#32;&amp;operator=(TaskQueue&#32;&amp;&amp;)&#32;=&#32;<emphasis role="keyword">delete</emphasis>;
13 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;TaskQueue&#32;&amp;operator=(<emphasis role="keyword">const</emphasis>&#32;TaskQueue&#32;&amp;)&#32;=&#32;<emphasis role="keyword">delete</emphasis>;
14 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
15 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">explicit</emphasis>&#32;TaskQueue()&#32;=&#32;<emphasis role="keywordflow">default</emphasis>;
16 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;~TaskQueue()&#32;=&#32;<emphasis role="keywordflow">default</emphasis>;
17 
18 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;push(<emphasis role="keyword">const</emphasis>&#32;T&amp;&#32;data)&#32;{
19 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::unique_lock&lt;std::mutex&gt;&#32;lock(_mutex);
20 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_cond_var.wait(lock,&#32;[<emphasis role="keyword">this</emphasis>]&#32;{
21 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;_datas_queue.size()&#32;&lt;=&#32;_max_size&#32;||&#32;!_running;&#32;
22 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;});
23 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!_running)&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
24 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_datas_queue.push_back(data);
25 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_cond_var.notify_one();
26 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">true</emphasis>;
27 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
28 
29 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;push(T&amp;&amp;&#32;data)&#32;{
30 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::unique_lock&lt;std::mutex&gt;&#32;lock(_mutex);
31 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_cond_var.wait(lock,&#32;[<emphasis role="keyword">this</emphasis>]&#32;{
32 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;_datas_queue.size()&#32;&lt;=&#32;_max_size&#32;||&#32;!_running;&#32;
33 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;});
34 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!_running)&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
35 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_datas_queue.push_back(data);
36 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_cond_var.notify_one();
37 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">true</emphasis>;
38 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
39 
40 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;pop(T&amp;&#32;data)&#32;{
41 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::unique_lock&lt;std::mutex&gt;&#32;lock(_mutex);
42 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_cond_var.wait(lock,&#32;[<emphasis role="keyword">this</emphasis>]&#32;{
43 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;!_datas_queue.empty()&#32;||&#32;!_running;
44 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;});
45 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!_running)&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
46 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;data&#32;=&#32;_datas_queue.front();
47 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_datas_queue.pop_front();
48 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_cond_var.notify_one();
49 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">true</emphasis>;
50 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
51 
52 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;clear()&#32;{
53 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::unique_lock&lt;std::mutex&gt;&#32;lock(_mutex);
54 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(_deletor)&#32;{
55 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::for_each(_datas_queue.begin(),&#32;_datas_queue.end(),&#32;[<emphasis role="keyword">this</emphasis>](T&amp;&#32;data){
56 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_deletor(data);
57 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;});
58 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
59 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_datas_queue.clear();
60 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
61 
62 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;start()&#32;{
63 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_running&#32;=&#32;<emphasis role="keyword">true</emphasis>;
64 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
65 
66 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;stop()&#32;{
67 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_running&#32;=&#32;<emphasis role="keyword">false</emphasis>;
68 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_cond_var.notify_all();
69 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
70 
71 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;[[nodiscard]]&#32;<emphasis role="keywordtype">bool</emphasis>&#32;isRunning()<emphasis role="keyword">&#32;const&#32;</emphasis>{
72 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;_running;
73 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
74 
75 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;setMaxSize(<emphasis role="keywordtype">size_t</emphasis>&#32;max_size)&#32;{
76 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_max_size&#32;=&#32;max_size;
77 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
78 
79 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;[[nodiscard]]&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;size()<emphasis role="keyword">&#32;const&#32;</emphasis>{
80 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;_datas_queue.size();
81 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
82 
83 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;[[nodiscard]]&#32;<emphasis role="keywordtype">bool</emphasis>&#32;empty()<emphasis role="keyword">&#32;const&#32;</emphasis>{
84 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;_datas_queue.empty();
85 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
86 
87 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;T&amp;&#32;front()<emphasis role="keyword">&#32;const&#32;</emphasis>{
88 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;_datas_queue.front();
89 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
90 
91 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">const</emphasis>&#32;T&amp;&#32;back()<emphasis role="keyword">&#32;const&#32;</emphasis>{
92 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;_datas_queue.back();
93 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
94 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
95 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;setDeletor(<emphasis role="keyword">const</emphasis>&#32;std::function&lt;<emphasis role="keywordtype">void</emphasis>(T&amp;)&gt;&amp;&#32;deletor)&#32;{
96 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;_deletor&#32;=&#32;deletor;
97 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
98 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
99 &#32;&#32;&#32;&#32;<emphasis role="keyword">private</emphasis>:
100 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::deque&lt;T&gt;&#32;_datas_queue;
101 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::mutex&#32;_mutex;
102 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::condition_variable&#32;_cond_var;
103 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::atomic&lt;bool&gt;&#32;_running{<emphasis role="keyword">false</emphasis>};
104 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;_max_size{50};
105 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::function&lt;void(T&amp;)&gt;&#32;_deletor;
106 &#32;&#32;&#32;&#32;};
107 }
108 
109 <emphasis role="preprocessor">#endif&#32;</emphasis><emphasis role="comment">//&#32;!QUEUE_H</emphasis>
</programlisting></section>
