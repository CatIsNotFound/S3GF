<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>S3GF: S3GF::Matrix2D&lt; T &gt; 模板结构体 参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">S3GF<span id="projectnumber">&#160;v0.1.0-beta</span>
   </div>
   <div id="projectbrief">SDL3 Graphics Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','搜索',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('struct_s3_g_f_1_1_matrix2_d.html','','struct_s3_g_f_1_1_matrix2_d-members'); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">S3GF::Matrix2D&lt; T &gt; 模板结构体 参考</div></div>
</div><!--header-->
<div class="contents">

<p>二维矩阵  
 <a href="#details">更多...</a></p>

<p><code>#include &lt;<a class="el" href="_basic_8h_source.html">Basic.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
类</h2></td></tr>
<tr class="memitem:Position" id="r_Position"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s3_g_f_1_1_matrix2_d_1_1_position.html">Position</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public 类型</h2></td></tr>
<tr class="memitem:a049aac5a2f199ae5a638e95249cb98bc" id="r_a049aac5a2f199ae5a638e95249cb98bc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a049aac5a2f199ae5a638e95249cb98bc">iterator</a> = typename std::vector&lt;T&gt;::iterator</td></tr>
<tr class="memitem:a5b81e73ad803348fd3bf9f85a16fc36e" id="r_a5b81e73ad803348fd3bf9f85a16fc36e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b81e73ad803348fd3bf9f85a16fc36e">constIterator</a> = typename std::vector&lt;T&gt;::const_iterator</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public 成员函数</h2></td></tr>
<tr class="memitem:aed07f777ece718aed0c4b44664da8d4c" id="r_aed07f777ece718aed0c4b44664da8d4c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed07f777ece718aed0c4b44664da8d4c">Matrix2D</a> ()</td></tr>
<tr class="memdesc:aed07f777ece718aed0c4b44664da8d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">创建一个空白的二维矩阵（没有任何数据）  <br /></td></tr>
<tr class="memitem:a7854b0a704c5ce2ebb912312ddc63f3f" id="r_a7854b0a704c5ce2ebb912312ddc63f3f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7854b0a704c5ce2ebb912312ddc63f3f">Matrix2D</a> (uint32_t row, uint32_t col, const std::function&lt; void(T &amp;)&gt; &amp;deleter={})</td></tr>
<tr class="memdesc:a7854b0a704c5ce2ebb912312ddc63f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">创建指定行列的二维矩阵  <br /></td></tr>
<tr class="memitem:a713e891d39ba2327b2814e79a2ecfce9" id="r_a713e891d39ba2327b2814e79a2ecfce9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a713e891d39ba2327b2814e79a2ecfce9">Matrix2D</a> (uint32_t row, uint32_t col, const T &amp;value, const std::function&lt; void(T &amp;)&gt; &amp;deleter={})</td></tr>
<tr class="memdesc:a713e891d39ba2327b2814e79a2ecfce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">创建指定行列与默认值的二维矩阵  <br /></td></tr>
<tr class="memitem:ae6f00a13ba3788d9f9b49e2b98fce862" id="r_ae6f00a13ba3788d9f9b49e2b98fce862"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6f00a13ba3788d9f9b49e2b98fce862">Matrix2D</a> (const <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">Matrix2D</a>&lt; T &gt; &amp;matrix)</td></tr>
<tr class="memdesc:ae6f00a13ba3788d9f9b49e2b98fce862"><td class="mdescLeft">&#160;</td><td class="mdescRight">复制原有的二维矩阵  <br /></td></tr>
<tr class="memitem:aa20722c49362e7dcaa92ee3b5852c0f4" id="r_aa20722c49362e7dcaa92ee3b5852c0f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa20722c49362e7dcaa92ee3b5852c0f4">~Matrix2D</a> ()</td></tr>
<tr class="memitem:a02a38ed57d98c1f08c31d1413df84e79" id="r_a02a38ed57d98c1f08c31d1413df84e79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02a38ed57d98c1f08c31d1413df84e79">setDeleter</a> (const std::function&lt; void(T &amp;)&gt; &amp;function)</td></tr>
<tr class="memdesc:a02a38ed57d98c1f08c31d1413df84e79"><td class="mdescLeft">&#160;</td><td class="mdescRight">设置删除器  <br /></td></tr>
<tr class="memitem:a9d80bdc758dc3116c89c426945701c11" id="r_a9d80bdc758dc3116c89c426945701c11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d80bdc758dc3116c89c426945701c11">fill</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a9d80bdc758dc3116c89c426945701c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">填充所有值  <br /></td></tr>
<tr class="memitem:a9f5615541ffb7d4e199e3aed68a920a0" id="r_a9f5615541ffb7d4e199e3aed68a920a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f5615541ffb7d4e199e3aed68a920a0">fillN</a> (const <a class="el" href="struct_s3_g_f_1_1_matrix2_d_1_1_position.html">Matrix2D::Position</a> &amp;start, const <a class="el" href="struct_s3_g_f_1_1_matrix2_d_1_1_position.html">Matrix2D::Position</a> &amp;<a class="el" href="#ab09942e50a2386f0063ed45ce9a27b14">end</a>, const T &amp;value)</td></tr>
<tr class="memdesc:a9f5615541ffb7d4e199e3aed68a920a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">填充范围内的值  <br /></td></tr>
<tr class="memitem:a165b63fd20be62abe7395872bb15e510" id="r_a165b63fd20be62abe7395872bb15e510"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a165b63fd20be62abe7395872bb15e510">resize</a> (uint32_t line, uint32_t col)</td></tr>
<tr class="memdesc:a165b63fd20be62abe7395872bb15e510"><td class="mdescLeft">&#160;</td><td class="mdescRight">重新调整新的大小  <br /></td></tr>
<tr class="memitem:ac4948b66fa919a16306467c75a353075" id="r_ac4948b66fa919a16306467c75a353075"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4948b66fa919a16306467c75a353075">at</a> (uint32_t row, uint32_t col)</td></tr>
<tr class="memdesc:ac4948b66fa919a16306467c75a353075"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取矩阵中指定行列的数据  <br /></td></tr>
<tr class="memitem:a2cf6c039cd92a178461dcb74e6c0a58e" id="r_a2cf6c039cd92a178461dcb74e6c0a58e"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cf6c039cd92a178461dcb74e6c0a58e">get</a> (uint32_t row, uint32_t col)</td></tr>
<tr class="memdesc:a2cf6c039cd92a178461dcb74e6c0a58e"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取矩阵中指定行列的数据  <br /></td></tr>
<tr class="memitem:abe52a7b2c1c6b15a98af6c23beb6c43a" id="r_abe52a7b2c1c6b15a98af6c23beb6c43a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe52a7b2c1c6b15a98af6c23beb6c43a">rows</a> () const</td></tr>
<tr class="memdesc:abe52a7b2c1c6b15a98af6c23beb6c43a"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取当前矩阵的总行数  <br /></td></tr>
<tr class="memitem:a03ca4385c2998fd25e1312b30da2ce64" id="r_a03ca4385c2998fd25e1312b30da2ce64"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03ca4385c2998fd25e1312b30da2ce64">cols</a> () const</td></tr>
<tr class="memdesc:a03ca4385c2998fd25e1312b30da2ce64"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取当前矩阵的总列数  <br /></td></tr>
<tr class="memitem:a3f3fb70a5fafc962387769fccccec870" id="r_a3f3fb70a5fafc962387769fccccec870"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">Matrix2D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f3fb70a5fafc962387769fccccec870">operator+</a> (const <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">Matrix2D</a>&lt; T &gt; &amp;other) const</td></tr>
<tr class="memitem:acdf0e2f07e6b0a88526c50e52a5110f0" id="r_acdf0e2f07e6b0a88526c50e52a5110f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">Matrix2D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acdf0e2f07e6b0a88526c50e52a5110f0">operator-</a> (const <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">Matrix2D</a>&lt; T &gt; &amp;other) const</td></tr>
<tr class="memitem:a86ac9b6ebf1bfba68b0b52fc180b7c28" id="r_a86ac9b6ebf1bfba68b0b52fc180b7c28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">Matrix2D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86ac9b6ebf1bfba68b0b52fc180b7c28">operator*</a> (const <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">Matrix2D</a>&lt; T &gt; &amp;other) const</td></tr>
<tr class="memdesc:a86ac9b6ebf1bfba68b0b52fc180b7c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">矩阵乘法  <br /></td></tr>
<tr class="memitem:afbfd5b6cb513bf8dc7f0688c71cfb7cb" id="r_afbfd5b6cb513bf8dc7f0688c71cfb7cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbfd5b6cb513bf8dc7f0688c71cfb7cb">operator==</a> (const <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">Matrix2D</a>&lt; T &gt; &amp;other) const</td></tr>
<tr class="memitem:a6cb781a43c26c22397733232e5faf6ef" id="r_a6cb781a43c26c22397733232e5faf6ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6cb781a43c26c22397733232e5faf6ef">operator!=</a> (const <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">Matrix2D</a>&lt; T &gt; &amp;other) const</td></tr>
<tr class="memitem:a3aa5523cc2c4f670f8b2c26247a7da99" id="r_a3aa5523cc2c4f670f8b2c26247a7da99"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3aa5523cc2c4f670f8b2c26247a7da99">operator[]</a> (uint32_t index)</td></tr>
<tr class="memitem:a1fcbdf1dee56e52565dcd2e9a2c89446" id="r_a1fcbdf1dee56e52565dcd2e9a2c89446"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1fcbdf1dee56e52565dcd2e9a2c89446">operator()</a> (uint32_t row, uint32_t col)</td></tr>
<tr class="memitem:ae8109e86f958f50937102386ade22f72" id="r_ae8109e86f958f50937102386ade22f72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a049aac5a2f199ae5a638e95249cb98bc">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8109e86f958f50937102386ade22f72">begin</a> ()</td></tr>
<tr class="memitem:ab09942e50a2386f0063ed45ce9a27b14" id="r_ab09942e50a2386f0063ed45ce9a27b14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a049aac5a2f199ae5a638e95249cb98bc">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab09942e50a2386f0063ed45ce9a27b14">end</a> ()</td></tr>
<tr class="memitem:a9629f52a27eefe4812357dcf32bc6454" id="r_a9629f52a27eefe4812357dcf32bc6454"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a5b81e73ad803348fd3bf9f85a16fc36e">constIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9629f52a27eefe4812357dcf32bc6454">begin</a> () const</td></tr>
<tr class="memitem:aa31b89ad35488a36ac62bd62a1e8b3be" id="r_aa31b89ad35488a36ac62bd62a1e8b3be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a5b81e73ad803348fd3bf9f85a16fc36e">constIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa31b89ad35488a36ac62bd62a1e8b3be">end</a> () const</td></tr>
<tr class="memitem:aa1f3d2fed8d89b728ffb33a2b4f7c8bd" id="r_aa1f3d2fed8d89b728ffb33a2b4f7c8bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1f3d2fed8d89b728ffb33a2b4f7c8bd">add</a> (T &amp;value, const std::function&lt; void(T &amp;, T &amp;)&gt; &amp;function={})</td></tr>
<tr class="memdesc:aa1f3d2fed8d89b728ffb33a2b4f7c8bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">全局相加  <br /></td></tr>
<tr class="memitem:a7847b7bac807d34b8cf7d415d3334d5e" id="r_a7847b7bac807d34b8cf7d415d3334d5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7847b7bac807d34b8cf7d415d3334d5e">add</a> (T &amp;&amp;value, const std::function&lt; void(T &amp;, T &amp;)&gt; &amp;function={})</td></tr>
<tr class="memdesc:a7847b7bac807d34b8cf7d415d3334d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">全局相加  <br /></td></tr>
<tr class="memitem:a10de43028db57bf1ee267d0ad308da5d" id="r_a10de43028db57bf1ee267d0ad308da5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10de43028db57bf1ee267d0ad308da5d">minus</a> (T &amp;value, const std::function&lt; void(T &amp;, T &amp;)&gt; &amp;function={})</td></tr>
<tr class="memdesc:a10de43028db57bf1ee267d0ad308da5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">全局相减  <br /></td></tr>
<tr class="memitem:a1ea94a9f46ed9958a85320e1c977b0b3" id="r_a1ea94a9f46ed9958a85320e1c977b0b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ea94a9f46ed9958a85320e1c977b0b3">minus</a> (T &amp;&amp;value, const std::function&lt; void(T &amp;, T &amp;)&gt; &amp;function={})</td></tr>
<tr class="memdesc:a1ea94a9f46ed9958a85320e1c977b0b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">全局相减  <br /></td></tr>
<tr class="memitem:af4a6573a2dde5a522fab15d0f540be79" id="r_af4a6573a2dde5a522fab15d0f540be79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4a6573a2dde5a522fab15d0f540be79">times</a> (T &amp;value, const std::function&lt; void(T &amp;, T &amp;)&gt; &amp;function={})</td></tr>
<tr class="memdesc:af4a6573a2dde5a522fab15d0f540be79"><td class="mdescLeft">&#160;</td><td class="mdescRight">全局乘法  <br /></td></tr>
<tr class="memitem:a515addae398644cf179d84694b78a067" id="r_a515addae398644cf179d84694b78a067"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a515addae398644cf179d84694b78a067">times</a> (T &amp;&amp;value, const std::function&lt; void(T &amp;, T &amp;)&gt; &amp;function={})</td></tr>
<tr class="memdesc:a515addae398644cf179d84694b78a067"><td class="mdescLeft">&#160;</td><td class="mdescRight">全局点乘  <br /></td></tr>
<tr class="memitem:a1bfb3131396c5e240b0cdbeb7fbd0dfe" id="r_a1bfb3131396c5e240b0cdbeb7fbd0dfe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1bfb3131396c5e240b0cdbeb7fbd0dfe">times</a> (const <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">Matrix2D</a>&lt; T &gt; &amp;other, const std::function&lt; void(T &amp;, const T &amp;)&gt; &amp;function={})</td></tr>
<tr class="memdesc:a1bfb3131396c5e240b0cdbeb7fbd0dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">矩阵点乘  <br /></td></tr>
<tr class="memitem:a137bfc4291e2f13615b8b97653837b62" id="r_a137bfc4291e2f13615b8b97653837b62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a137bfc4291e2f13615b8b97653837b62">multiply</a> (const <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">Matrix2D</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:a137bfc4291e2f13615b8b97653837b62"><td class="mdescLeft">&#160;</td><td class="mdescRight">矩阵乘法  <br /></td></tr>
<tr class="memitem:ac8604cc529b2204944aa63e6231fd0cd" id="r_ac8604cc529b2204944aa63e6231fd0cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8604cc529b2204944aa63e6231fd0cd">transpose</a> ()</td></tr>
<tr class="memdesc:ac8604cc529b2204944aa63e6231fd0cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">转置矩阵  <br /></td></tr>
<tr class="memitem:a1868e22e69ab5647ec816c1e02f2ba65" id="r_a1868e22e69ab5647ec816c1e02f2ba65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1868e22e69ab5647ec816c1e02f2ba65">reverse</a> (bool reverse_row=true, bool reverse_col=false)</td></tr>
<tr class="memdesc:a1868e22e69ab5647ec816c1e02f2ba65"><td class="mdescLeft">&#160;</td><td class="mdescRight">翻转矩阵  <br /></td></tr>
<tr class="memitem:ae58dfa4d53e1cbca83ea16c63cdae2fb" id="r_ae58dfa4d53e1cbca83ea16c63cdae2fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae58dfa4d53e1cbca83ea16c63cdae2fb">rotate</a> (bool turn_right=true)</td></tr>
<tr class="memdesc:ae58dfa4d53e1cbca83ea16c63cdae2fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">旋转矩阵  <br /></td></tr>
<tr class="memitem:ae198f6a0096d36ebd4c7057a2ed92b30" id="r_ae198f6a0096d36ebd4c7057a2ed92b30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">Matrix2D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae198f6a0096d36ebd4c7057a2ed92b30">splitRows</a> (uint32_t start_row, uint32_t end_row)</td></tr>
<tr class="memdesc:ae198f6a0096d36ebd4c7057a2ed92b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">切割指定行矩阵  <br /></td></tr>
<tr class="memitem:a97e3123ad6e70a823e9a72f303a274c9" id="r_a97e3123ad6e70a823e9a72f303a274c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">Matrix2D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97e3123ad6e70a823e9a72f303a274c9">splitCols</a> (uint32_t start_col, uint32_t end_col)</td></tr>
<tr class="memdesc:a97e3123ad6e70a823e9a72f303a274c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">切割指定列矩阵  <br /></td></tr>
<tr class="memitem:a3cb1819fae99784b50762b1795c896d4" id="r_a3cb1819fae99784b50762b1795c896d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">Matrix2D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3cb1819fae99784b50762b1795c896d4">split</a> (uint32_t <a class="el" href="#abe52a7b2c1c6b15a98af6c23beb6c43a">rows</a>, uint32_t <a class="el" href="#a03ca4385c2998fd25e1312b30da2ce64">cols</a>, const <a class="el" href="struct_s3_g_f_1_1_matrix2_d_1_1_position.html">Position</a> &amp;start_pos)</td></tr>
<tr class="memdesc:a3cb1819fae99784b50762b1795c896d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">切割矩阵  <br /></td></tr>
<tr class="memitem:af3e0c0b296e145fdb4318274b84d1e8c" id="r_af3e0c0b296e145fdb4318274b84d1e8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">Matrix2D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3e0c0b296e145fdb4318274b84d1e8c">split</a> (<a class="el" href="struct_s3_g_f_1_1_matrix2_d_1_1_position.html">Matrix2D::Position</a> start_pos, <a class="el" href="struct_s3_g_f_1_1_matrix2_d_1_1_position.html">Matrix2D::Position</a> end_pos)</td></tr>
<tr class="memdesc:af3e0c0b296e145fdb4318274b84d1e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">按照矩形的方式切割矩阵  <br /></td></tr>
<tr class="memitem:a9ce5027bdadbb48fff7a104fab675978" id="r_a9ce5027bdadbb48fff7a104fab675978"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">Matrix2D</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ce5027bdadbb48fff7a104fab675978">inverse</a> ()</td></tr>
<tr class="memdesc:a9ce5027bdadbb48fff7a104fab675978"><td class="mdescLeft">&#160;</td><td class="mdescRight">逆矩阵  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">详细描述</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
struct S3GF::Matrix2D&lt; T &gt;</div><p>二维矩阵 </p>
<dl class="section since"><dt>自从</dt><dd>v1.1.0-alpha</dd></dl>
<p>支持使用基本数据类型及简单的结构体进行存储。 </p>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">成员类型定义说明</h2>
<a id="a5b81e73ad803348fd3bf9f85a16fc36e" name="a5b81e73ad803348fd3bf9f85a16fc36e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b81e73ad803348fd3bf9f85a16fc36e">&#9670;&#160;</a></span>constIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::constIterator = typename std::vector&lt;T&gt;::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a049aac5a2f199ae5a638e95249cb98bc" name="a049aac5a2f199ae5a638e95249cb98bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a049aac5a2f199ae5a638e95249cb98bc">&#9670;&#160;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::iterator = typename std::vector&lt;T&gt;::iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">构造及析构函数说明</h2>
<a id="aed07f777ece718aed0c4b44664da8d4c" name="aed07f777ece718aed0c4b44664da8d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed07f777ece718aed0c4b44664da8d4c">&#9670;&#160;</a></span>Matrix2D() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::Matrix2D </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>创建一个空白的二维矩阵（没有任何数据） </p>

</div>
</div>
<a id="a7854b0a704c5ce2ebb912312ddc63f3f" name="a7854b0a704c5ce2ebb912312ddc63f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7854b0a704c5ce2ebb912312ddc63f3f">&#9670;&#160;</a></span>Matrix2D() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::Matrix2D </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(T &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>deleter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>创建指定行列的二维矩阵 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>行 </td></tr>
    <tr><td class="paramname">col</td><td>列 </td></tr>
    <tr><td class="paramname">deleter</td><td>删除器（若需要删除指针等情况时指定） </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a713e891d39ba2327b2814e79a2ecfce9" name="a713e891d39ba2327b2814e79a2ecfce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a713e891d39ba2327b2814e79a2ecfce9">&#9670;&#160;</a></span>Matrix2D() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::Matrix2D </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(T &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>deleter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>创建指定行列与默认值的二维矩阵 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>行 </td></tr>
    <tr><td class="paramname">col</td><td>列 </td></tr>
    <tr><td class="paramname">value</td><td>默认值（用于填充所有数据） </td></tr>
    <tr><td class="paramname">deleter</td><td>删除器（若需要删除指针等情况时指定） </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6f00a13ba3788d9f9b49e2b98fce862" name="ae6f00a13ba3788d9f9b49e2b98fce862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6f00a13ba3788d9f9b49e2b98fce862">&#9670;&#160;</a></span>Matrix2D() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::Matrix2D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">Matrix2D</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>复制原有的二维矩阵 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>指定二维矩阵 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa20722c49362e7dcaa92ee3b5852c0f4" name="aa20722c49362e7dcaa92ee3b5852c0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa20722c49362e7dcaa92ee3b5852c0f4">&#9670;&#160;</a></span>~Matrix2D()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::~<a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">Matrix2D</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">成员函数说明</h2>
<a id="a7847b7bac807d34b8cf7d415d3334d5e" name="a7847b7bac807d34b8cf7d415d3334d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7847b7bac807d34b8cf7d415d3334d5e">&#9670;&#160;</a></span>add() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::add </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(T &amp;, T &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>function</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>全局相加 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>指定值 </td></tr>
    <tr><td class="paramname">function</td><td>函数（对于复杂的数据类型，此参数必需指定）</td></tr>
  </table>
  </dd>
</dl>
<p>将矩阵里的所有值进行相加操作 </p>

</div>
</div>
<a id="aa1f3d2fed8d89b728ffb33a2b4f7c8bd" name="aa1f3d2fed8d89b728ffb33a2b4f7c8bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f3d2fed8d89b728ffb33a2b4f7c8bd">&#9670;&#160;</a></span>add() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::add </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(T &amp;, T &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>function</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>全局相加 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>指定值 </td></tr>
    <tr><td class="paramname">function</td><td>函数（对于复杂的数据类型，此参数必需指定）</td></tr>
  </table>
  </dd>
</dl>
<p>将矩阵里的所有值进行相加操作 </p>

</div>
</div>
<a id="ac4948b66fa919a16306467c75a353075" name="ac4948b66fa919a16306467c75a353075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4948b66fa919a16306467c75a353075">&#9670;&#160;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>col</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>获取矩阵中指定行列的数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>行 </td></tr>
    <tr><td class="paramname">col</td><td>列 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>返回对应行列下的数据 </dd></dl>
<dl class="section see"><dt>参见</dt><dd><a class="el" href="#a2cf6c039cd92a178461dcb74e6c0a58e" title="获取矩阵中指定行列的数据">get</a> </dd></dl>

</div>
</div>
<a id="ae8109e86f958f50937102386ade22f72" name="ae8109e86f958f50937102386ade22f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8109e86f958f50937102386ade22f72">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a049aac5a2f199ae5a638e95249cb98bc">iterator</a> <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9629f52a27eefe4812357dcf32bc6454" name="a9629f52a27eefe4812357dcf32bc6454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9629f52a27eefe4812357dcf32bc6454">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a5b81e73ad803348fd3bf9f85a16fc36e">constIterator</a> <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a03ca4385c2998fd25e1312b30da2ce64" name="a03ca4385c2998fd25e1312b30da2ce64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03ca4385c2998fd25e1312b30da2ce64">&#9670;&#160;</a></span>cols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::cols </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取当前矩阵的总列数 </p>
<dl class="section return"><dt>返回</dt><dd>返回对应的列数 </dd></dl>

</div>
</div>
<a id="ab09942e50a2386f0063ed45ce9a27b14" name="ab09942e50a2386f0063ed45ce9a27b14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab09942e50a2386f0063ed45ce9a27b14">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a049aac5a2f199ae5a638e95249cb98bc">iterator</a> <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa31b89ad35488a36ac62bd62a1e8b3be" name="aa31b89ad35488a36ac62bd62a1e8b3be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa31b89ad35488a36ac62bd62a1e8b3be">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a5b81e73ad803348fd3bf9f85a16fc36e">constIterator</a> <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d80bdc758dc3116c89c426945701c11" name="a9d80bdc758dc3116c89c426945701c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d80bdc758dc3116c89c426945701c11">&#9670;&#160;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>填充所有值 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>指定值 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f5615541ffb7d4e199e3aed68a920a0" name="a9f5615541ffb7d4e199e3aed68a920a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f5615541ffb7d4e199e3aed68a920a0">&#9670;&#160;</a></span>fillN()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::fillN </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">Matrix2D</a>&lt; T &gt;::Position &amp;</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">Matrix2D</a>&lt; T &gt;::Position &amp;</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>填充范围内的值 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>指定开始位置（行列） </td></tr>
    <tr><td class="paramname">end</td><td>指定结束位置（行列） </td></tr>
    <tr><td class="paramname">value</td><td>指定填充的值 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2cf6c039cd92a178461dcb74e6c0a58e" name="a2cf6c039cd92a178461dcb74e6c0a58e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf6c039cd92a178461dcb74e6c0a58e">&#9670;&#160;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>col</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>获取矩阵中指定行列的数据 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>行 </td></tr>
    <tr><td class="paramname">col</td><td>列 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>返回对应行列下的数据 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>区别于 <span class="tt">at</span>，此函数为常量版本，无法修改里面的数据！ </dd></dl>
<dl class="section see"><dt>参见</dt><dd><a class="el" href="#ac4948b66fa919a16306467c75a353075" title="获取矩阵中指定行列的数据">at</a> </dd></dl>

</div>
</div>
<a id="a9ce5027bdadbb48fff7a104fab675978" name="a9ce5027bdadbb48fff7a104fab675978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce5027bdadbb48fff7a104fab675978">&#9670;&#160;</a></span>inverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">Matrix2D</a>&lt; T &gt; <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::inverse </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>逆矩阵 </p>
<dl class="section return"><dt>返回</dt><dd>返回新的矩阵，用于存储求得的结果 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>当前仅支持整数、浮点数运算，不支持其它数据类型的运算！ </dd>
<dd>
两个矩阵的大小必需完全一致！否则将返回空矩阵！ </dd></dl>

</div>
</div>
<a id="a1ea94a9f46ed9958a85320e1c977b0b3" name="a1ea94a9f46ed9958a85320e1c977b0b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ea94a9f46ed9958a85320e1c977b0b3">&#9670;&#160;</a></span>minus() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::minus </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(T &amp;, T &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>function</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>全局相减 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>指定值 </td></tr>
    <tr><td class="paramname">function</td><td>函数（对于复杂的数据类型，此参数必需指定）</td></tr>
  </table>
  </dd>
</dl>
<p>将矩阵里的所有值进行相减操作 </p>

</div>
</div>
<a id="a10de43028db57bf1ee267d0ad308da5d" name="a10de43028db57bf1ee267d0ad308da5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10de43028db57bf1ee267d0ad308da5d">&#9670;&#160;</a></span>minus() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::minus </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(T &amp;, T &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>function</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>全局相减 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>指定值 </td></tr>
    <tr><td class="paramname">function</td><td>函数（对于复杂的数据类型，此参数必需指定）</td></tr>
  </table>
  </dd>
</dl>
<p>将矩阵里的所有值进行相减操作 </p>

</div>
</div>
<a id="a137bfc4291e2f13615b8b97653837b62" name="a137bfc4291e2f13615b8b97653837b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a137bfc4291e2f13615b8b97653837b62">&#9670;&#160;</a></span>multiply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::multiply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">Matrix2D</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>矩阵乘法 </p>
<p>将矩阵里的所有值进行乘法操作 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>指定矩阵，其指定的行数必需与现有的列数相等 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>当前仅支持整数、浮点数运算，不支持其它数据类型的运算！ </dd>
<dd>
两个矩阵必需分别为 m * n, n * p 的大小才可用！ </dd></dl>

</div>
</div>
<a id="a6cb781a43c26c22397733232e5faf6ef" name="a6cb781a43c26c22397733232e5faf6ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb781a43c26c22397733232e5faf6ef">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">Matrix2D</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1fcbdf1dee56e52565dcd2e9a2c89446" name="a1fcbdf1dee56e52565dcd2e9a2c89446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fcbdf1dee56e52565dcd2e9a2c89446">&#9670;&#160;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>col</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a86ac9b6ebf1bfba68b0b52fc180b7c28" name="a86ac9b6ebf1bfba68b0b52fc180b7c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86ac9b6ebf1bfba68b0b52fc180b7c28">&#9670;&#160;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">Matrix2D</a>&lt; T &gt; <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">Matrix2D</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>矩阵乘法 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>指定矩阵，其指定的行数必需与现有的列数相等</td></tr>
  </table>
  </dd>
</dl>
<p>将矩阵里的所有值进行乘法操作 </p><dl class="section note"><dt>注解</dt><dd>当前仅支持整数、浮点数运算，不支持其它数据类型的运算！ </dd>
<dd>
两个矩阵必需分别为 m * n, n * p 的大小才可用！ </dd></dl>

</div>
</div>
<a id="a3f3fb70a5fafc962387769fccccec870" name="a3f3fb70a5fafc962387769fccccec870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f3fb70a5fafc962387769fccccec870">&#9670;&#160;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">Matrix2D</a>&lt; T &gt; <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">Matrix2D</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acdf0e2f07e6b0a88526c50e52a5110f0" name="acdf0e2f07e6b0a88526c50e52a5110f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdf0e2f07e6b0a88526c50e52a5110f0">&#9670;&#160;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">Matrix2D</a>&lt; T &gt; <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">Matrix2D</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afbfd5b6cb513bf8dc7f0688c71cfb7cb" name="afbfd5b6cb513bf8dc7f0688c71cfb7cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbfd5b6cb513bf8dc7f0688c71cfb7cb">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">Matrix2D</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3aa5523cc2c4f670f8b2c26247a7da99" name="a3aa5523cc2c4f670f8b2c26247a7da99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aa5523cc2c4f670f8b2c26247a7da99">&#9670;&#160;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a165b63fd20be62abe7395872bb15e510" name="a165b63fd20be62abe7395872bb15e510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a165b63fd20be62abe7395872bb15e510">&#9670;&#160;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>line</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>col</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>重新调整新的大小 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">line</td><td>行 </td></tr>
    <tr><td class="paramname">col</td><td>列 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1868e22e69ab5647ec816c1e02f2ba65" name="a1868e22e69ab5647ec816c1e02f2ba65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1868e22e69ab5647ec816c1e02f2ba65">&#9670;&#160;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::reverse </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>reverse_row</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>reverse_col</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>翻转矩阵 </p>
<p>当选择任何一个方向的逆序时，都会发生交换。 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">reverse_row</td><td>行与行之间逆序（垂直翻转） </td></tr>
    <tr><td class="paramname">reverse_col</td><td>列与列之间逆序（水平翻转） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>当两个参数都为 <span class="tt">true</span> 时，矩阵将完全逆序 </dd></dl>
<dl class="section see"><dt>参见</dt><dd><a class="el" href="#ae58dfa4d53e1cbca83ea16c63cdae2fb" title="旋转矩阵">rotate</a> </dd></dl>

</div>
</div>
<a id="ae58dfa4d53e1cbca83ea16c63cdae2fb" name="ae58dfa4d53e1cbca83ea16c63cdae2fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae58dfa4d53e1cbca83ea16c63cdae2fb">&#9670;&#160;</a></span>rotate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::rotate </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>turn_right</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>旋转矩阵 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">turn_right</td><td>是否向右旋转 90°，反之向左旋转 90° </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>参见</dt><dd><a class="el" href="#a1868e22e69ab5647ec816c1e02f2ba65" title="翻转矩阵">reverse</a> </dd>
<dd>
<a class="el" href="#ac8604cc529b2204944aa63e6231fd0cd" title="转置矩阵">transpose</a> </dd></dl>

</div>
</div>
<a id="abe52a7b2c1c6b15a98af6c23beb6c43a" name="abe52a7b2c1c6b15a98af6c23beb6c43a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe52a7b2c1c6b15a98af6c23beb6c43a">&#9670;&#160;</a></span>rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::rows </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel nodiscard">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>获取当前矩阵的总行数 </p>
<dl class="section return"><dt>返回</dt><dd>返回对应的行数 </dd></dl>

</div>
</div>
<a id="a02a38ed57d98c1f08c31d1413df84e79" name="a02a38ed57d98c1f08c31d1413df84e79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02a38ed57d98c1f08c31d1413df84e79">&#9670;&#160;</a></span>setDeleter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::setDeleter </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(T &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>function</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>设置删除器 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>指定函数</td></tr>
  </table>
  </dd>
</dl>
<p>当此类析构时，将调用删除器以删除指针！ </p>

</div>
</div>
<a id="af3e0c0b296e145fdb4318274b84d1e8c" name="af3e0c0b296e145fdb4318274b84d1e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e0c0b296e145fdb4318274b84d1e8c">&#9670;&#160;</a></span>split() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">Matrix2D</a>&lt; T &gt; <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">Matrix2D</a>&lt; T &gt;::Position</td>          <td class="paramname"><span class="paramname"><em>start_pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">Matrix2D</a>&lt; T &gt;::Position</td>          <td class="paramname"><span class="paramname"><em>end_pos</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>按照矩形的方式切割矩阵 </p>
<p>根据起始位置和结束位置包围成一个矩形，并将其切割成独立的矩阵。 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_pos</td><td>起始位置 </td></tr>
    <tr><td class="paramname">end_pos</td><td>结束位置 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>返回切割后的矩阵。 </dd></dl>

</div>
</div>
<a id="a3cb1819fae99784b50762b1795c896d4" name="a3cb1819fae99784b50762b1795c896d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb1819fae99784b50762b1795c896d4">&#9670;&#160;</a></span>split() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">Matrix2D</a>&lt; T &gt; <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::split </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>cols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_s3_g_f_1_1_matrix2_d_1_1_position.html">Position</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>start_pos</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>切割矩阵 </p>
<p>切割原有的矩阵，根据 <span class="tt">start_pos</span> 位置开始，取 <span class="tt">rows * cols</span> 个数据并创建成新的矩阵。 </p><dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>新的行数 </td></tr>
    <tr><td class="paramname">cols</td><td>新的列数 </td></tr>
    <tr><td class="paramname">start_pos</td><td>从哪个位置开始 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>返回新的大小为 <span class="tt">(rows * cols)</span> 的二维矩阵。</dd></dl>
<dl class="section note"><dt>注解</dt><dd>从 <span class="tt">start_pos</span> 位置起，若取得数据的总个数小于新的矩阵大小，则剩余部分自动填充为空数据。 </dd>
<dd>
指定的 <span class="tt">start_pos</span> 位置若超出原有矩阵的范围，将返回空矩阵。 </dd></dl>

</div>
</div>
<a id="a97e3123ad6e70a823e9a72f303a274c9" name="a97e3123ad6e70a823e9a72f303a274c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e3123ad6e70a823e9a72f303a274c9">&#9670;&#160;</a></span>splitCols()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">Matrix2D</a>&lt; T &gt; <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::splitCols </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>start_col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>end_col</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>切割指定列矩阵 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_col</td><td>起始列 </td></tr>
    <tr><td class="paramname">end_col</td><td>结束列 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>返回矩阵行位于 <span class="tt">[start_col, end_col)</span> 区间内的所有列矩阵 </dd></dl>

</div>
</div>
<a id="ae198f6a0096d36ebd4c7057a2ed92b30" name="ae198f6a0096d36ebd4c7057a2ed92b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae198f6a0096d36ebd4c7057a2ed92b30">&#9670;&#160;</a></span>splitRows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">Matrix2D</a>&lt; T &gt; <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::splitRows </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>start_row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>end_row</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>切割指定行矩阵 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_row</td><td>起始行 </td></tr>
    <tr><td class="paramname">end_row</td><td>结束行 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>返回矩阵行位于 <span class="tt">[start_row, end_row)</span> 区间内的所有行矩阵 </dd></dl>

</div>
</div>
<a id="a1bfb3131396c5e240b0cdbeb7fbd0dfe" name="a1bfb3131396c5e240b0cdbeb7fbd0dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bfb3131396c5e240b0cdbeb7fbd0dfe">&#9670;&#160;</a></span>times() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::times </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">Matrix2D</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(T &amp;, const T &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>function</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>矩阵点乘 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>指定矩阵 </td></tr>
    <tr><td class="paramname">function</td><td>函数（对于复杂的数据类型，此参数必需指定） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>两个矩阵的大小必需完全一样（即行列必需相等）！ </dd></dl>

</div>
</div>
<a id="a515addae398644cf179d84694b78a067" name="a515addae398644cf179d84694b78a067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a515addae398644cf179d84694b78a067">&#9670;&#160;</a></span>times() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::times </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(T &amp;, T &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>function</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>全局点乘 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>指定值 </td></tr>
    <tr><td class="paramname">function</td><td>函数（对于复杂的数据类型，此参数必需指定）</td></tr>
  </table>
  </dd>
</dl>
<p>将矩阵里的所有值进行点乘操作 </p>

</div>
</div>
<a id="af4a6573a2dde5a522fab15d0f540be79" name="af4a6573a2dde5a522fab15d0f540be79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a6573a2dde5a522fab15d0f540be79">&#9670;&#160;</a></span>times() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::times </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(T &amp;, T &amp;)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>function</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>全局乘法 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>指定值 </td></tr>
    <tr><td class="paramname">function</td><td>函数（对于复杂的数据类型，此参数必需指定）</td></tr>
  </table>
  </dd>
</dl>
<p>将矩阵里的所有值进行相乘操作 </p>

</div>
</div>
<a id="ac8604cc529b2204944aa63e6231fd0cd" name="ac8604cc529b2204944aa63e6231fd0cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8604cc529b2204944aa63e6231fd0cd">&#9670;&#160;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="struct_s3_g_f_1_1_matrix2_d.html">S3GF::Matrix2D</a>&lt; T &gt;::transpose </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>转置矩阵 </p>
<p>将原有的 m * n 大小的矩阵转置为 n * m 大小的矩阵。 </p><dl class="section see"><dt>参见</dt><dd><a class="el" href="#ae58dfa4d53e1cbca83ea16c63cdae2fb" title="旋转矩阵">rotate</a> </dd></dl>

</div>
</div>
<hr/>该结构体的文档由以下文件生成:<ul>
<li>D:/Coding/S3GF/src/<a class="el" href="_basic_8h_source.html">Basic.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespace_s3_g_f.html">S3GF</a></li><li class="navelem"><a href="struct_s3_g_f_1_1_matrix2_d.html">Matrix2D</a></li>
    <li class="footer">生成于 <span class="timestamp"></span> , 为 S3GF使用  <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
